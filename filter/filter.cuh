#ifndef _FILTER_H_
#define _FILTER_H_

//////////////////////////////////////////////////////////////
// dependencies
/////////////////////////////////////////////////////////////
#include <random>
#include <iostream>
#include <string>

#include <curand.h>
#include <curand_kernel.h>

//#include "utilities.cuh"
#include "settings.cuh"
#include "cub/cub.cuh" // for block reduction of weights

//extern double get_current_time();
extern void checkCUDAError(const std::string msg);


//////////////////////////////////////////////////////////////
// Device functions
/////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////
// motion equations
/////////////////////////////////////////////////////////////
__device__ float dynamicsAlpha( float alpha, float beta, float alpha_dot, float beta_dot );
__device__ float dynamicsBeta( float alpha, float beta, float alpha_dot );

//////////////////////////////////////////////////////////////
// project world points to image points transforming the camera
// or each point
/////////////////////////////////////////////////////////////
__device__ void projectWorldPt( const float *camera, const float *worldPt, const float states[], float imPt[] );

//////////////////////////////////////////////////////////////
// transform a single world point
/////////////////////////////////////////////////////////////
__device__ void transformPt( const float T[12], const float *worldPt, float pt3D[3] );


//////////////////////////////////////////////////////////////
//  Make a (truncated) transformation matrix given the states
/////////////////////////////////////////////////////////////
__device__ void statesToTransform( const float states[], float T[] );

    
//////////////////////////////////////////////////////////////
// Transform camera to new reference frame given a state
/////////////////////////////////////////////////////////////
__device__ void transformCamera( const float *camera, const float states[], float newCamera[] );
    
//////////////////////////////////////////////////////////////
// Project 3D world point using a given camera to a 2D point
/////////////////////////////////////////////////////////////
__device__ void project( const float worldPt[], const float *camera, float imPt[] );

//////////////////////////////////////////////////////////////
// compute normal from 2 image points
/////////////////////////////////////////////////////////////
__device__ void computeNormal( const float *imPts, float *n );

//////////////////////////////////////////////////////////////
// search for interval containing val in arr
/////////////////////////////////////////////////////////////
__device__ int findInterval( float val, const float *arr );

//////////////////////////////////////////////////////////////
// update kernel
/////////////////////////////////////////////////////////////
__global__ void observation_kernel(cudaTextureObject_t texObj, const float *cameraPtr, const float *worldPtsPtr, float *statesPtr, float *weightPtr, float *weightSum);

__global__ void motion_kernel( curandState *rngStates, float time_left, float *statesPtr );


/*************************************** RESAMPLE *************************************/
//////////////////////////////////////////////////////////////
// resample and normalize kernel 
/////////////////////////////////////////////////////////////
__global__ void normalize_kernel( float *weightPtr, const float *weightSum );
__global__ void resample_kernel(  curandState *rngStates, const float *weights, const float *fromStates, float *toStates );

//////////////////////////////////////////////////////////////
// mean kernel
/////////////////////////////////////////////////////////////
__global__ void mean_kernel( const float *statesPtr, float *meanStates );

//////////////////////////////////////////////////////////////
// PRNG
/////////////////////////////////////////////////////////////
__global__ void setupRNG_kernel( curandState *rngStates, unsigned int seed );

class Filter
{
public:

    Filter(){}
    
    Filter( const float mu[], const float sigma[], const float worldPoints[] );		

    ~Filter();

//////////////////////////////////////////////////////////////
// initalize particles 
/////////////////////////////////////////////////////////////
    void init( const float mu[], const float sigma[], const float worldPoints[] );

    
//////////////////////////////////////////////////////////////
// update motion and observation
/////////////////////////////////////////////////////////////
    void update( float startTime, float endTime, const float *d_camera, cudaTextureObject_t texObj, cudaStream_t motionStream=0 );

//////////////////////////////////////////////////////////////
// resample
/////////////////////////////////////////////////////////////
    void resample();

//////////////////////////////////////////////////////////////
// mean
/////////////////////////////////////////////////////////////
    void mean();

//////////////////////////////////////////////////////////////
// operator []
/////////////////////////////////////////////////////////////
    float operator[]( int idx )
	{
	    if( idx>=0 && idx<N_STATES )
		return h_meanStates[idx];

	    std::cerr << "Filter: Out of bounds\n";
	    return 0.0f;
	}

    
private:

//////////////////////////////////////////////////////////////
// normalize and compute cumulative sum
/////////////////////////////////////////////////////////////
    void normalize();

//////////////////////////////////////////////////////////////
// member variables
/////////////////////////////////////////////////////////////


    float h_meanStates[N_STATES] = {0.0f};
    float *d_meanStates;

    float *states;
    float *d_states1;
    float *d_states2;
    
    float *d_weights;

    float *d_worldPoints;

    float *d_weightSum;
    float *d_cumsum;

    int h_resampleIdx[N_PARTICLES];
    int *d_resampleIdx;

    curandState *d_rngStates;

    void *d_temp_storage;
    size_t temp_storage_bytes;
};



#endif /* _FILTER_H_ */
